---
title: coverctl
description: Domain-aware test coverage enforcement for any codebase
template: splash
hero:
  tagline: Stop chasing a single coverage number. Enforce coverage policies where it matters most - at the domain level. Works with Go, Python, JavaScript, Rust, and Java.
  image:
    file: ../../assets/logo.svg
  actions:
    - text: Get Started
      link: /coverctl/installation/
      icon: right-arrow
    - text: GitHub
      link: https://github.com/felixgeelhaar/coverctl
      icon: external
      variant: minimal
---

import { Card, CardGrid, LinkCard } from '@astrojs/starlight/components';

<div class="hero-supplement">

Your core business logic deserves 90% coverage. Your HTTP handlers? Maybe 70%.
**coverctl** lets you define and enforce these policies per domain.

</div>

---

## The Problem

Traditional coverage tools give you one number for your entire codebase. But real applications have layers:

- **Core domain logic** needs strict coverage - bugs here cost money
- **API handlers** need solid coverage - they're your contract with users
- **Infrastructure code** can have lower thresholds - it's often integration-heavy

A single percentage hides these distinctions. You either over-test utilities or under-test critical paths.

---

## The Solution

Define coverage policies that match your architecture:

```yaml title=".coverctl.yaml"
version: 1
policy:
  default:
    min: 70
  domains:
    - name: core
      match: ["./internal/core/..."]
      min: 90
    - name: api
      match: ["./internal/api/..."]
      min: 80
    - name: infra
      match: ["./internal/infra/..."]
      min: 60
exclude:
  - internal/generated/*
```

---

## Quick Start

```bash
# Install
go install github.com/felixgeelhaar/coverctl@latest

# Initialize (interactive wizard)
coverctl init

# Enforce policies
coverctl check
```

That's it. Coverage enforcement that understands your architecture.

---

<CardGrid>
  <Card title="Domain-Aware Policies" icon="puzzle">
    Set different coverage thresholds for each domain. Core logic at 90%, utilities at 60%.
  </Card>
  <Card title="Multi-Language Support" icon="laptop">
    Works with Go, Python, JavaScript/TypeScript, Rust, and Java. Auto-detects your project type.
  </Card>
  <Card title="CI-Ready" icon="github">
    JSON output, GitHub Actions annotations, and exit codes for any CI system.
  </Card>
  <Card title="Auto-Discovery" icon="magnifier">
    Automatically detects your project structure. Interactive wizard or `--no-interactive` for scripts.
  </Card>
</CardGrid>

---

## Beyond Basic Coverage

<CardGrid>
  <LinkCard
    title="Build Flags"
    description="Pass --tags, --race, --timeout to customize test runs."
    href="/coverctl/guides/build-flags/"
  />
  <LinkCard
    title="Watch Mode"
    description="Continuous coverage feedback during development."
    href="/coverctl/cli/watch/"
  />
  <LinkCard
    title="Ratcheting"
    description="Prevent coverage regression with --ratchet in CI."
    href="/coverctl/guides/ci-integration/"
  />
  <LinkCard
    title="Debt Reports"
    description="Identify files that need more test coverage."
    href="/coverctl/cli/report/"
  />
</CardGrid>

---

## Designed for Teams

coverctl is built with domain-driven design principles. It understands that different parts of your codebase have different criticality levels.

- **Explicit policies** - No guessing what coverage is expected
- **CI enforcement** - Catch regressions before they merge
- **Clear feedback** - Know exactly which domain failed and why

---

<div class="cta-section">

Ready to enforce coverage where it matters?

[Get Started](/coverctl/installation/) | [View on GitHub](https://github.com/felixgeelhaar/coverctl)

</div>
